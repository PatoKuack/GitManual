<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comandos de git</title>
</head>
<body>
  <header>
    <section>
      <div>
        <h1>Comandos de git.</h1>
      </div>
    </section>
  </header>
  <main>
    <section>
      <div>
        <dl>
          <dt>alias <span>nombrarAlias</span>="<span>instrucción</span>"</dt>
          <dd>Permite llamar una instrucción escribiendo solo un alias (ejemplo: alias arbolito="git log --all ...").</dd>
          <dt>git config --global alias.<span>nombre_del_alias</span> "<span>instrucción</span>"</dt>
          <dd>Guarda el alias en la terminal de git para evitar que se borre al reiniciar la computadora (Se manda llamar con: git <u>alias</u>).</dd>
          <dt>git init</dt>
          <dd>Arranca un repositorio.</dd>
          <dt>q</dt>
          <dd>salirte de un estado.</dd>
          <p class="importnt">Si tu rama principal no es "main" y es "master" o algún otro nombre, se debe modificar para que sea "main".<br/>
          <a href="#cambioRama">Como cambiar nombre a la rama principal</a></p>
          <dt>git add</dt>
          <dd>
            <dl>
              <dt>git add <span>___.txt</span></dt>
              <dd>Agrega el archivo o sus cambios al repositorio (en la memoria RAM). se prepara para ingresarse a la base de datos.</dd>
              <dt>git add <span>.</span></dt>
              <dd>Agrega todos los cambios que se hayan hecho a los archivos de la carpeta en donde se esta pocicionado.</dd>
            </dl>
          </dd>
          <dt>git rm</dt>
          <dd>
            <dl>
              <dt>git rm --cached</dt>
              <dd>Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.</dd>
              <dt>git rm --cached <span>__.txt</span></dt>
              <dd>Elimina el archivo del repositorio antes de que ingrese a la base de datos.</dd>
              <dt>git rm --force</dt>
              <dd>Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).</dd>
            </dl>
          </dd>
          <dt>git commit</dt>
          <dd>
            <dl>
              <dt>git commit</dt>
              <dd>Envia los ultimos cambios del archivo a la base de datos del sistema de control de versiones para controlar los cambios que se le hayan hecho. *Cada que se agregan (add) archivos se tiene que enviar los cambios a la base de datos (commit). Si no se le agrega mensaje se abre un VIN donde se coloca el mensaje con CTRL+i y se finaliza el VIN con ESC+SHIFT+Z+Z.</dd>
              <dt>git commit -m "<span>mensaje</span>"</dt>
              <dd>La "-m" indica que se le agregará un mensaje para poder verlo en el futuro como una referencia del cambio.</dd>
              <dt>git commit -am "<span>mensaje</span>"</dt>
              <dd>Hace un add junto con el commit y el mensaje, solo se debe utilizar con archivos que ya hayan sido ejecutados con un "git add" previamente, es decir, no funciona para archivos recien creados.</dd>
              <dt>git commit --amend</dt>
              <dd>
                Incluye un cambio hecho al proyecto al último commit hecho, pero se debe de hacer un "add" antes de usar este commit. También esta instrucción da la opción de modificar el mensaje del commit en el que se guardarán estos últimos cambios.
                <p class="inportnt">*No se utiliza con commits que ya esten en el repositorio remoto.</p>
              </dd>
            </dl>
          </dd>
          <dt>git status</dt>
          <dd>Muestra el estatus de los cambios hechos, se usa para verificar los cambios.</dd>
          <dt>git show</dt>
          <dd>
            <dl>
              <dt>git show</dt>
              <dd>Muestra todos los cambios historicos hechos, cuando y quien hizo los cambios. También muestra a que apunta el HEAD (principalmente solo a 'main')</dd>
              <dt>git show <span>__.txt</span></dt>
              <dd>Muestra los cambios de un archivo especifico.</dd>
            </dl>
          </dd>
          <dt>git log</dt>
          <dd>
            <dl>
              <dt>git log <span>___.txt</span></dt>
              <dd>Muestra el historial completo del archivo.</dd>
              <dt>git log --stat</dt>
              <dd>Muestra los cambios especificos realizados en los archivos apartir del commit.</dd>
              <dt>git log --all</dt>
              <dd>Muestra todo lo hecho historicamente.</dd>
              <dt>git log --all --graph</dt>
              <dd>Muestra por medio de unas lineas en el margen lateral como han funcionado las ramas.</dd>
              <dt>git log --all --graph --decorate --oneline</dt>
              <dd>Muestra toda la historia del proyecto desde que se inicializa.</dd>
              <dt>git log --oneline</dt>
              <dd>Muestra el historial de cambios en una forma reducida.</dd>
            </dl>
          </dd>
          <dt>git reflog</dt>
          <dd>Muestra toda la actividad que ha tenido el proyecto.</dd>
          <dt>git config</dt>
          <dd>
            <dl>
              <dt>git config</dt>
              <dd>Muestra una lista de todas las configuraciones que tiene git y como funcionan.</dd>
              <dt>git config --list</dt>
              <dd>Muestra la configuracion por defecto del git y las que le faltan.</dd>
              <dt>git config --list --show-origin</dt>
              <dd>Muestra las configuraciones guardadas.</dd>
              <dt>git config --global user.name "<span>NAME</span>"</dt>
              <dd>Modifica la configuracion de los usuarios globales de git colocando un nombre.</dd>
              <dt>git config --global user.email "<span>E-MAIL</span>"</dt>
              <dd>Lo mismo pero coloca un e-mal.</dd>
            </dl>
          </dd>
          <dt>git diff</dt>
          <dd>
            <dl>
              <dt>git diff</dt>
              <dd>Muestra los cambios entre los cambios guardados en la memoria RAM y los guardados en el disco duro.</dd>
              <dt>git diff <span>id-commit1 id-commit2</span></dt>
              <dd>compara dos versiones guardadas de un archivo.</dd>
            </dl>
          </dd>
          <dt>git reset</dt>
          <dd>
            <dl>
              <p>Con ayuda de "<i>git reflog</i>" se obtiene el hash o id de cada commit o cambio en el proyecto:</p>
              <figure>
                <img src="../Imgs/reflog1.jpg" alt="Ejemplo del comando 'git reflog'" title="git reflog">
              </figure>
              <dt>git reset --soft</dt>
              <dd>Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.</dd>
              <dt>git reset <span>id-commit</span> --soft</dt>
              <dd>Se posiciona en la version especificada y elimina las versiones posteriores a esa del repositorio.</dd>
              <dt>git reset --hard</dt>
              <dd>Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging, se borra el historial.</dd>
              <dt>git reset --hard <span>id-commit</span></dt>
              <dd>
                <u>Restaura los documentos</u> a la version especificada del repositorio y elimina las versiones posteriores de git y del disco duro.
                <p class="importnt">*Es una mala practica.</p>
              </dd>
              <dt>git reset HEAD</dt>
              <dd>Este es el comando para sacar archivos del área de Staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.</dd>
            </dl>
          </dd>
          <dt>git clone <span>URL_del_servidor_remoto</span></dt>
          <dd>Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.</dd>
          <dt>git push</dt>
          <dd>Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.</dd>
          <p class="importnt">*Los archivos binarios no se deben agregar al repositorio debido a que lo hacen más pesado.</p>
          <dt>git fetch</dt>
          <dd>Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (se ejecuta antes del git push).</dd>
          <dt>git merge <span>nombre_de_la_rama</span></dt>
          <dd>Usamos este comando con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo. Se debe posicionar en la rama a la que se le quieren fusionar los cambios (generalmente se posiciona en la rama principal, o sea main) y en el comando se coloca el nombre de la rama que se le quiere combinar.</dd>
          <dt>git pull</dt>
          <dd>Basicamente, git fetch y git merge al mismo tiempo.</dd>
          <dt>git branch</dt>
          <dd>
            <dl>
              <dt>git branch</dt>
              <dd>Muestra todas las ramas existentes en el proyecto de git.</dd>
              <dt>git branch o git branch -l</dt>
              <dd>Muestra una lista de todas las ramas que existen.</dd>
              <dt>git branch <span>nombre_de_la_rama</span></dt>
              <dd>Crea una rama del proyecto con el nombre especificado. Esta rama contendrá una copia del último commit.</dd>
              <dt>git branch -d <span>nombre_de_la_rama</span></dt>
              <dd>Elimina la rama especificada (con '-d' se fuerza el borrado).</dd>
              <dt>git branch -m <span>nombreRamaVieja nombreRamaNueva</span></dt>
              <dd>Renombra una rama colocando el nombre de la rama actual y el nombre por el que se desea cambiarla.</dd>
              <dt>git show-branch</dt>
              <dd>Muestra las ramas que existen y cuál ha sido su historia dentro del proyecto.</dd>
              <dt>git show-branch --all</dt>
              <dd>Muestra un poco de más información.</dd>
              <dt>gitk</dt>
              <dd>Muestra de una forma visual toda la historia del proyecto.</dd>
            </dl>
          </dd>
          <dt>git checkout</dt>
          <dd>
            <p>
              (Se deben guardar los cambios correspondientes en el repositorio actual antes de cambiar de version del commit o de rama).
            </p>
            <dl>
              <dt>git checkout <span>id-commit archivo.txt</span></dt>
              <dd>Nos devuelve el archivo especificado a la version de commit especificada. Si se hace un commit en este estado se borrara todo lo creado despues de esta version.</dd>
              <dt>git checkout main <span>archivo.txt</span></dt>
              <dd>nos devuelve la ultima version del archivo especificado.</dd>
              <dt>git checkout <span>nombre_de_la_rama</span></dt>
              <dd>Nos mueve a la rama especificada.</dd>
              <dt>git checkout -b <span>nombre_de_la_rama</span></dt>
              <dd>Crea una nueva rama con el nombre especificado y nos posiciona en ella.</dd>
            </dl>
          </dd>
          <dt>git remote</dt>
          <dd>
            <dl>
              <dt>git remote</dt>
              <dd>Muestra el tipo de repositorio que tenemos disponibles.</dd>
              <dt>git remote -v</dt>
              <dd>Muestra el tipo de repositorio disponible, su URL y las acciones que se pueden hacer con él como usar fetch (importar proyectos) o push (exportar proyectos).</dd>
              <dt>git remote add origin <span>URL_(HTTPS_o_SSH)</span></dt>
              <dd>Agrega un orígen remoto de nuestros archivos.</dd>
            </dl>
          </dd>
          <dt>git pull</dt>
          <dd>
            <dl>
              <dt>git pull origin main</dt>
              <dd>Importa a nuestro "origin" los cambios de la rama "main" (repositorio en GitHub).</dd>
              <dt>git pull origin main --allow-unrelated-histories</dt>
              <dd>Permite fusionar la rama (o branch) remota con la rama (o branch) local (generalmente se usa este comando la primera vez que se hace pull).</dd>
              <dt>git pull <span>rama_local</span> main</dt>
              <dd>Importa a una rama local el contenido que hay en la rama "main".</dd>
            </dl>
          </dd>
          <dt>git push origin main</dt>
          <dd>Exporta o envía nuestro "origin" la rama "main" de GitHub.</dd>
          <dt>cd ~</dt>
          <dd>La "~" (alt+126) nos dirige al home</dd>
          <p class="importnt">*Se crea una llave SSH por cada computadora.</p>
          <dt>ssh-keygen -t rsa -b 4096 -C "<span>correo@mail.com</span>"</dt>
          <dd>
            <u>Se coloca éste código desde home (~).</u><br/>
            Lo que hace es que genera una llave de SSH para una mayor seguridad en el proyecto.<br/>
            Con "-t" se especifica el algoritmo que se utilizará para crear la llave que en este caso es rsa.<br/>
            Con "-b" se especifica que tan compleja es la llave.<br/>
            Con "4096" se indica la complejidad de la llave desde una perspectiva matemática.<br/>
            Con "-C" se indica a que correo electrónico va a estar conectada la llave y el cual debe ser el correo que tenemos en nuestro repositorio de GitHub.<br/>
            Después de ingresar el código se da enter si es que la dirección de almacenamiento sugerido es deseada o sino se puede escribir una dirección deseada.<br/>
            Se puede ingresar una contraseña con espacios llamada "passphrase" para mayor seguridad.
          </dd>
          <figure>
            <img src="../Imgs/SSH1.jpg" alt="generar llave SSH (ubicación)" title="generar llave SSH (ubicación)">
            <img src="../Imgs/SSH2.jpg" alt="generar llave SSH (passphrase)" title="generar llave SSH (passphrase)">
          </figure>
          <p class="importnt">*La llave privada nunca se comparte.</p>
          <p>Una vez que se tiene la llave se debe agregar al entorno (indicarle al sistema operativo que la llave existe).</p>
          <dt>eval $(ssh-agent -s)</dt>
          <dd>
            Verifica que el servidor de llaves esta activo: "Agent" indica que el servidor de SSH esta activo, "pid" es el id del proceso y el número al final indica que el proceso esta activo.
          </dd>
          <figure>
            <img src="../Imgs/SSH3.jpg" alt="Verificación del servidor activo" title="Verificación del servidor activo">
          </figure>
          <dt>ssh-add <span>~/.ssh/id_rsa</span></dt>
          <dd>
            En home por default se encuentra la carpeta ".ssh" (como empieza por punto se supone que es una carpeta oculta), en donde se encuentran las llaves publicas y privadas.<br/>
            El comando agregará la llave al sistema, debe contener la ruta de la llave <u>privada</u>.
          </dd>
          <figure>
            <img src="../Imgs/SSH4.jpg" alt="agregar llave al sistema" title="agregar llave al sistema">
          </figure>
          <p>
            Después de haber creando nuestro entorno local, nos conectamos con GitHub y se remplaza la conexión HTTPS por una conexión SSH para hacer git pull y git push sin usar contraseñas y seguir manteniendo una conexión segura.
          </p>
          <p>Los tags o etiquetas nos permiten asignar versiones a los commits con cambios más importantes o significativos de nuestro proyecto. Son útiles en el sitio web de GitHub porque es la forma en que otros usuarios pueden visualizar que verciones ocurrieron y rara vez son útiles dentro del proyecto ya que solo se usrían para dejar un registro interno.</p>
          <figure>
            <img src="../Imgs/tag1.jpg" alt="ejemplo de la obtención de hash" title="ejemplo de la obtención de hash">
            <figcaption>Primero se escoje y se copia uno de los <b>hash</b>s que se desea usar para crear el tag.</figcaption>
          </figure>
          <dt>git tag</dt>
          <dd>
            <dl>
              <dt>git tag</dt>
              <dd>Muestra los tags que existen en el proyecto.</dd>
              <dt>git tag -a <span>nombre_del_tag</span> -m "<span>mensaje descriptivo del tag</span>" <span>hash</span></dt>
              <dd>
                "-a" indica que se agregará un tag.<br/>
                Generalmente se le coloca un nombre como v0.1 (versión 0.1 del proyecto).
              </dd>
              <dt>git show-ref --tag</dt>
              <dd>Muestra a que hash o a que commit esta conectado un tag.</dd>
              <p>Como los tags no son archivos no se envian con un simple push.</p>
              <dt>git pull origin main</dt>
              <dd>Como buena practica, antes de subir a la web un tag, se obtiene el repositorio de GitHub.</dd>
              <dt>git push origin --tags</dt>
              <dd>Le envia a origin los tags creados.</dd>
              <dt>git tag -d <span>nombre_del_tag</span></dt>
              <dd>Elimina un tag del proyecto en git (no de GitHub).</dd>
              <dt>git push origin :refs/tags/<span>nombre_del_tag</span></dt>
              <dd>Elimina el tag de GitHub que esta conectado con el tag eliminado dentro del proyecto en git (puede que previamente se tenga que usar pull y push para subir la referencia del tag eliminado en el proyecto de git).</dd>
            </dl>
          </dd>
          <figure>
            <img src="../Imgs/tag2.jpg" alt="ejemplo de tag mandado a GitHub" title="ejemplo de tag mandado a GitHub">
            <img src="../Imgs/tag3.jpg" alt="ejemplo de tag en GitHub" title="ejemplo de tag en GitHub">
          </figure>
          <dt>git rebase <span>nombre_de_la_rama</span></dt>
          <dd>
            Con rebase puedes recoger todos los cambios confirmados en una rama y ponerlos sobre otra.
            <p>
              Primero se le hace un rebase a la rama a la que se aderirá la rama en la que se esta posicionado, con esto se actualizará automaticamente la rama en la que se esta posicionado con los ultimos cambios hechos a la rama especificada en el comando y después se hace un rebase a la rama que se le aderirá estando posicionado en la rama a la que se le aderirá, ejemplo:
            </p>
            <ul>
              <li>(rama2)$ git rebase rama2</li>
              <li>(main)$ git rebase rama2</li>
            </ul>
            <p>Primero se le hace rebase a la rama con los cambios que se aderirán y luego a la rama que va a quedar con todo unido.</p>
            <p>Los problemas con éste comando son que no queda historia, no queda registro de las actividades de los usuarios y si hay muchos cambios entre ramas crea muchos conflictos que se tienen que resolver manualmente.</p>
          </dd>
          <p class="importnt">*REBASE solo se debe usar en repositorios locales y nunca en remotos.</p>
          <dt>git stash</dt>
          <dd>
            <dl>
              <p>Es una forma útil de tener almacenados en una memoria temporal los cambios recientes del proyecto, poder moverlos entre ramas y después volver a recuperarlos.</p>
              <p>Podemos usar git stash para guardar cambios sin hacer commit y cambiar de rama.</p>
              <p>git stash es usado cuando tenemos cambios que no merecen una rama o no merecen un rebase si no simplemente estamos probando algo y luego se necesita volver rápidamente a tu versión anterior la cual es la correcta.</p>
              <dt>git stash</dt>
              <dd>Teniendo un cambio en el proyecto se aplica <i>git stash</i> y los cambios se guardarán haciendo que el proyecto vuelva a su forma antes de los cambios sin commit.</dd>
              <dt>git stash list</dt>
              <dd>Muestra una lista de stash guardados.</dd>
              <dt>git stash pop</dt>
              <dd>Aplica el stash guardado al proyecto de la rama en la que se esta posicionado.</dd>
              <dt>git stash branch <span>nombre_de_la_rama</span></dt>
              <dd>copia el proyecto y aplica los cambios en una rama nueva.</dd>
              <dt>git stash drop</dt>
              <dd>Elimina el stage guardado.</dd>
            </dl>
          </dd>
          <dt>git clean</dt>
          <dd>
            <dl>
              <dt>git clean --dry-run</dt>
              <dd>Simula una eliminación de archivos innecesarios (sin seguimiento que se puede indexar), muestra en pantalla los archivos que se eliminarían.</dd>
              <dt>git clean -f</dt>
              <dd>Elimina los archivos innecesarios mostrados con "dry-run".</dd>
              <dt>git clean -df</dt>
              <dd>Elimina los archivos y carpetas innecesarias.</dd>
              <dt>git clean -xdf</dt>
              <dd>Elimina los archivos y carpetas innecesarias aunque en el documento <i>.gitignore</i> estén indicadoas para ser ignoradas.</dd>
            </dl>
          </dd>
          <dt>git cherry-pick <span>código_del_commit</span></dt>
          <dd>Posicionado en una rama A, trae los cambios especificos realizados en un commit de la rama B.</dd>
          <p class="inportnt">*Cherry-pick es una mala practica porque recontruye la historia del proyecto.</p>
          <dt>git grep</dt>
          <dd>
            <dt>git grep "<span>palabra</span>"</dt>
            <dd>Busca una palabra en todos los <u>documentos</u> de la rama del proyecto en donde se esta posicionado y muestra los documentos en donde se encuentra esa palabra junto con su línea de código.</dd>
            <dt>git grep -n "<span>palabra</span>"</dt>
            <dd>Busca la palabra en todos los <u>documentos</u> de la rama del proyecto en donde se esta posicionado y muestra los documentos en donde se encuentra esa palabra junto con su línea de código y la línea del código en donde se encuentra.</dd>
            <dt>git grep -c "<span>palabra</span>"</dt>
            <dd>Busca la palabra y muestra en que <u>documentos</u> se encuentra junto con las veces que se repite esa palabra en ese documento.</dd>
          </dd>
          <dt>git log -S "<span>palabra</span>"</dt>
          <dd>Busca y muestra los <u>commit</u> en los que esta involucrada la palabra especificada.</dd>
          <h3>Alias dentro de Git.</h3>
          <dt>git shortlog -sn</dt>
          <dd>Muestra cuantos commit han hecho cada miembro del equipo.</dd>
          <dt>git shortlog -sn --all</dt>
          <dd>Muestra cuantos commit han hecho cada miembro del equipo hasta los que han sido eliminado.</dd>
          <dt>git shortlog -sn --all --no-merge</dt>
          <dd>Muestra cuantos commit han hecho cada miembros quitando los eliminados sin los merges.</dd>
          <dt>git blame -c <span>archivo</span></dt>
          <dd>Muestra quien hizo cada cambio del proyecto línea por línea.</dd>
          <dt>git <span>comando</span> --help</dt>
          <dd>Muestra como funciona el comando especificado abriendo el navegador con el manual de cada comando.</dd>
          <dt>git blame <span>archivo</span> -L<span>línea_inicial</span>,<span>línea_final</span> -c</dt>
          <dd>Muestra quien hizo cada cosa línea por línea indicándole desde que línea ver, ejemplo: -L<span>35</span>,<span>50</span></dd>
          <dt>git branch -r</dt>
          <dd>Muestra todas las ramas remotas.</dd>
          <dt>git branch -a</dt>
          <dd>Muestra todas las ramas () locales (e) y remotas (e).
            <ul>
              <li>En verde y con asterisco la rama en la que se esta posicionado.</li>
              <li>En color blanco las ramas locales.</li>
              <li>En color ojo las ramas remotas.</li>
            </ul>
            </dd>
        </dl>
      </div>
    </section>
  </main>
</body>
</html>