<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../Estilos/styleGit1.css">
  <title>Git Bash (Windows)</title>
</head>
<body>
  <header>
    <h1>Git Bash (entorno Windows)</h1>
  </header>
  <main>
    <section>
      <figure>
        <img src="../Imgs/staging.jpg" alt="Comandos del stating (status, add, commit y reset)" title="Comandos del stating">
        <img src="../Imgs/rm y reset.jpg" alt="Comandos rm y reset" title="Comandos rm y reset">
        <img src="../Imgs/rm y reset 2.jpg" alt="Diferencia de comandos rm y reset" title="Diferencia de comandos rm y reset">
        <img src="../Imgs/branch_merge.jpg" alt="Ramificación (branch y merge)" title="Ramificación (branch y merge)">
      </figure>
      <div>
        <dl>
          <dt>alias <span>nombrarAlias</span>="<span>instrucción</span>"</dt>
          <dd>Permite llamar una instrucción escribiendo solo un alias (ejemplo: alias arbolito="git log --all ...").</dd>
          <dt>git config --global alias.superlog "<span>nombre_del_alias</span>"</dt>
          <dd>Guarda el alias para evitar que se borre al reiniciar la computadora.</dd>
          <dt>git init</dt>
          <dd>Arranca un repositorio.</dd>
          <dt>q</dt>
          <dd>salirte de un estado.</dd>
          <p class="importnt">Si tu rama principal no es "main" y es "master" o algún otro nombre, se debe modificar para que sea "main".<br/>
          <a href="#cambioRama">Como cambiar nombre a la rama principal</a></p>
          <dt>git add</dt>
          <dd>
            <dl>
              <dt>git add <span>___.txt</span></dt>
              <dd>Agrega el archivo o sus cambios al repositorio (en la memoria RAM). se prepara para ingresarse a la base de datos.</dd>
              <dt>git add <span>.</span></dt>
              <dd>Agrega todos los cambios que se hayan hecho a los archivos de la carpeta en donde se esta pocicionado.</dd>
            </dl>
          </dd>
          <dt>git rm</dt>
          <dd>
            <dl>
              <dt>git rm --cached</dt>
              <dd>Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.</dd>
              <dt>git rm --cached <span>__.txt</span></dt>
              <dd>Elimina el archivo del repositorio antes de que ingrese a la base de datos.</dd>
              <dt>git rm --force</dt>
              <dd>Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).</dd>
            </dl>
          </dd>
          <dt>git commit</dt>
          <dd>
            <dl>
              <dt>git commit</dt>
              <dd>Envia los ultimos cambios del archivo a la base de datos del sistema de control de versiones para controlar los cambios que se le hayan hecho. *Cada que se agregan (add) archivos se tiene que enviar los cambios a la base de datos (commit). Si no se le agrega mensaje se abre un VIN donde se coloca el mensaje con CTRL+i y se finaliza el VIN con ESC+SHIFT+Z+Z.</dd>
              <dt>git commit -m "<span>mensaje</span>"</dt>
              <dd>La "-m" indica que se le agregará un mensaje para poder verlo en el futuro como una referencia del cambio.</dd>
              <dt>git commit -am "<span>mensaje</span>"</dt>
              <dd>Hace un add junto con el commit y el mensaje, solo se debe utilizar con archivos que ya hayan sido ejecutados con un "git add" previamente, es decir, no funciona para archivos recien creados.</dd>
            </dl>
          </dd>
          <dt>git status</dt>
          <dd>Muestra el estatus de los cambios hechos, se usa para verificar los cambios.</dd>
          <dt>git show</dt>
          <dd>
            <dl>
              <dt>git show</dt>
              <dd>Muestra todos los cambios historicos hechos, cuando y quien hizo los cambios. También muestra a que apunta el HEAD (principalmente solo a 'main')</dd>
              <dt>git show <span>__.txt</span></dt>
              <dd>Muestra los cambios de un archivo especifico.</dd>
            </dl>
          </dd>
          <dt>git log</dt>
          <dd>
            <dl>
              <dt>git log <span>___.txt</span></dt>
              <dd>Muestra el historial completo del archivo.</dd>
              <dt>git log --stat</dt>
              <dd>Muestra los cambios especificos realizados en los archivos apartir del commit.</dd>
              <dt>git log --all</dt>
              <dd>Muestra todo lo hecho historicamente.</dd>
              <dt>git log --all --graph</dt>
              <dd>Muestra por medio de unas lineas en el margen lateral como han funcionado las ramas.</dd>
              <dt>git log --all --graph --decorate --oneline</dt>
              <dd>Muestra toda la historia del proyecto desde que se inicializa</dd>
            </dl>
          </dd>
          <dt>git config</dt>
          <dd>
            <dl>
              <dt>git config</dt>
              <dd>Muestra una lista de todas las configuraciones que tiene git y como funcionan.</dd>
              <dt>git config --list</dt>
              <dd>Muestra la configuracion por defecto del git y las que le faltan.</dd>
              <dt>git config --list --show-origin</dt>
              <dd>Muestra las configuraciones guardadas.</dd>
              <dt>git config --global user.name "<span>NAME</span>"</dt>
              <dd>Modifica la configuracion de los usuarios globales de git colocando un nombre.</dd>
              <dt>git config --global user.email "<span>E-MAIL</span>"</dt>
              <dd>Lo mismo pero coloca un e-mal.</dd>
            </dl>
          </dd>
          <dt>git diff</dt>
          <dd>
            <dl>
              <dt>git diff</dt>
              <dd>Muestra los cambios entre los cambios guardados en la memoria RAM y los guardados en el disco duro.</dd>
              <dt>git diff <span>id-commit1 id-commit2</span></dt>
              <dd>compara dos versiones guardadas de un archivo.</dd>
            </dl>
          </dd>
          <dt>git reset</dt>
          <dd>
            <dl>
              <dt>git reset --soft</dt>
              <dd>Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.</dd>
              <dt>git reset <span>id-commit</span> --soft</dt>
              <dd>Se posiciona en la version especificada y elimina las versiones posteriores a esa del repositorio.</dd>
              <dt>git reset --hard</dt>
              <dd>Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging, se borra el historial.</dd>
              <dt>git reset <span>id-commit</span> --hard</dt>
              <dd>Restaura los documentos a la version especificada del repositorio y elimina las versiones posteriores de git y del disco duro.</dd>
              <dt>git reset HEAD</dt>
              <dd>Este es el comando para sacar archivos del área de Staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.</dd>
            </dl>
          </dd>
          <dt>git clone <span>URL_del_servidor_remoto</span></dt>
          <dd>Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.</dd>
          <dt>git push</dt>
          <dd>Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.</dd>
          <p class="importnt">*Los archivos binarios no se deben agregar al repositorio debido a que lo hacen más pesado.</p>
          <dt>git fetch</dt>
          <dd>Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (se ejecuta antes del git push).</dd>
          <dt>git merge <span>nombre_de_la_rama</span></dt>
          <dd>Usamos este comando con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo. Se debe posicionar en la rama a la que se le quieren fusionar los cambios (generalmente se posiciona en la rama principal, o sea main) y en el comando se coloca el nombre de la rama que se le quiere combinar.</dd>
          <dt>git pull</dt>
          <dd>Basicamente, git fetch y git merge al mismo tiempo.</dd>
          <dt>git branch</dt>
          <dd>
            <dl>
              <dt>git branch</dt>
              <dd>Muestra todas las ramas existentes en el proyecto de git.</dd>
              <dt>git branch o git branch -l</dt>
              <dd>Muestra una lista de todas las ramas que existen.</dd>
              <dt>git branch <span>nombre_de_la_rama</span></dt>
              <dd>Crea una rama del proyecto con el nombre especificado. Esta rama contendrá una copia del último commit.</dd>
              <dt>git branch -d <span>nombre_de_la_rama</span></dt>
              <dd>Elimina la rama especificada (con '-d' se fuerza el borrado).</dd>
              <dt>git branch -m <span>nombreRamaVieja nombreRamaNueva</span></dt>
              <dd>Renombra una rama colocando el nombre de la rama actual y el nombre por el que se desea cambiarla.</dd>
              <dt>git show-branch</dt>
              <dd>Muestra las ramas que existen y cuál ha sido su historia dentro del proyecto.</dd>
              <dt>git show-branch --all</dt>
              <dd>Muestra un poco de más información.</dd>
              <dt>gitk</dt>
              <dd>Muestra de una forma visual toda la historia del proyecto.</dd>
            </dl>
          </dd>
          <dt>git checkout</dt>
          <dd>
            <p>
              (Se deben guardar los cambios correspondientes en el repositorio actual antes de cambiar de version del commit o de rama).
            </p>
            <dl>
              <dt>git checkout <span>id-commit archivo.txt</span></dt>
              <dd>Nos devuelve el archivo especificado a la version de commit especificada. Si se hace un commit en este estado se borrara todo lo creado despues de esta version.</dd>
              <dt>git checkout main <span>archivo.txt</span></dt>
              <dd>nos devuelve la ultima version del archivo especificado.</dd>
              <dt>git checkout <span>nombre_de_la_rama</span></dt>
              <dd>Nos mueve a la rama especificada.</dd>
              <dt>git checkout -b <span>nombre_de_la_rama</span></dt>
              <dd>Crea una nueva rama con el nombre especificado y nos posiciona en ella.</dd>
            </dl>
          </dd>
          <dt>git remote</dt>
          <dd>
            <dl>
              <dt>git remote</dt>
              <dd>Muestra el tipo de repositorio que tenemos disponibles.</dd>
              <dt>git remote -v</dt>
              <dd>Muestra el tipo de repositorio disponible, su URL y las acciones que se pueden hacer con él como usar fetch (importar proyectos) o push (exportar proyectos).</dd>
              <dt>git remote add origin <span>URL_(HTTPS_o_SSH)</span></dt>
              <dd>Agrega un orígen remoto de nuestros archivos.</dd>
            </dl>
          </dd>
          <dt>git pull</dt>
          <dd>
            <dl>
              <dt>git pull origin main</dt>
              <dd>Importa a nuestro "origin" los cambios de la rama "main" (repositorio en GitHub).</dd>
              <dt>git pull origin main --allow-unrelated-histories</dt>
              <dd>Permite fusionar la rama (o branch) remota con la rama (o branch) local (generalmente se usa este comando la primera vez que se hace pull).</dd>
              <dt>git pull <span>rama_local</span> main</dt>
              <dd>Importa a una rama local el contenido que hay en la rama "main".</dd>
            </dl>
          </dd>
          <dt>git push origin main</dt>
          <dd>Exporta o envía nuestro "origin" la rama "main" de GitHub.</dd>
          <dt>cd ~</dt>
          <dd>La "~" (alt+126) nos dirige al home</dd>
          <p class="importnt">*Se crea una llave SSH por cada computadora.</p>
          <dt>ssh-keygen -t rsa -b 4096 -C "<span>correo@mail.com</span>"</dt>
          <dd>
            <u>Se coloca éste código desde home (~).</u><br/>
            Lo que hace es que genera una llave de SSH para una mayor seguridad en el proyecto.<br/>
            Con "-t" se especifica el algoritmo que se utilizará para crear la llave que en este caso es rsa.<br/>
            Con "-b" se especifica que tan compleja es la llave.<br/>
            Con "4096" se indica la complejidad de la llave desde una perspectiva matemática.<br/>
            Con "-C" se indica a que correo electrónico va a estar conectada la llave y el cual debe ser el correo que tenemos en nuestro repositorio de GitHub.<br/>
            Después de ingresar el código se da enter si es que la dirección de almacenamiento sugerido es deseada o sino se puede escribir una dirección deseada.<br/>
            Se puede ingresar una contraseña con espacios llamada "passphrase" para mayor seguridad.
          </dd>
          <figure>
            <img src="../Imgs/SSH1.jpg" alt="generar llave SSH (ubicación)" title="generar llave SSH (ubicación)">
            <img src="../Imgs/SSH2.jpg" alt="generar llave SSH (passphrase)" title="generar llave SSH (passphrase)">
          </figure>
          <p class="importnt">*La llave privada nunca se comparte.</p>
          <p>Una vez que se tiene la llave se debe agregar al entorno (indicarle al sistema operativo que la llave existe).</p>
          <dt>eval $(ssh-agent -s)</dt>
          <dd>
            Verifica que el servidor de llaves esta activo: "Agent" indica que el servidor de SSH esta activo, "pid" es el id del proceso y el número al final indica que el proceso esta activo.
          </dd>
          <figure>
            <img src="../Imgs/SSH3.jpg" alt="Verificación del servidor activo" title="Verificación del servidor activo">
          </figure>
          <dt>ssh-add <span>~/.ssh/id_rsa</span></dt>
          <dd>
            En home por default se encuentra la carpeta ".ssh" (como empieza por punto se supone que es una carpeta oculta), en donde se encuentran las llaves publicas y privadas.<br/>
            El comando agregará la llave al sistema, debe contener la ruta de la llave <u>privada</u>.
          </dd>
          <figure>
            <img src="../Imgs/SSH4.jpg" alt="agregar llave al sistema" title="agregar llave al sistema">
          </figure>
          <p>
            Después de haber creando nuestro entorno local, nos conectamos con GitHub y se remplaza la conexión HTTPS por una conexión SSH para hacer git pull y git push sin usar contraseñas y seguir manteniendo una conexión segura.
          </p>
          <p>Los tags o etiquetas nos permiten asignar versiones a los commits con cambios más importantes o significativos de nuestro proyecto. Son útiles en el sitio web de GitHub porque es la forma en que otros usuarios pueden visualizar que verciones ocurrieron y rara vez son útiles dentro del proyecto ya que solo se usrían para dejar un registro interno.</p>
          <figure>
            <img src="../Imgs/tag1.jpg" alt="ejemplo de la obtención de hash" title="ejemplo de la obtención de hash">
            <figcaption>Primero se escoje y se copia uno de los <b>hash</b>s que se desea usar para crear el tag.</figcaption>
          </figure>
          <dt>git tag</dt>
          <dd>
            <dl>
              <dt>git tag</dt>
              <dd>Muestra los tags que existen en el proyecto.</dd>
              <dt>git tag -a <span>nombre_del_tag</span> -m "<span>mensaje descriptivo del tag</span>" <span>hash</span></dt>
              <dd>
                "-a" indica que se agregará un tag.<br/>
                Generalmente se le coloca un nombre como v0.1 (versión 0.1 del proyecto).
              </dd>
              <dt>git show-ref --tag</dt>
              <dd>Muestra a que hash o a que commit esta conectado un tag.</dd>
              <p>Como los tags no son archivos no se envian con un simple push.</p>
              <dt>git pull origin main</dt>
              <dd>Como buena practica, antes de subir a la web un tag, se obtiene el repositorio de GitHub.</dd>
              <dt>git push origin --tags</dt>
              <dd>Le envia a origin los tags creados.</dd>
              <dt>git tag -d <span>nombre_del_tag</span></dt>
              <dd>Elimina un tag del proyecto en git (no de GitHub).</dd>
              <dt>git push origin :refs/tags/<span>nombre_del_tag</span></dt>
              <dd>Elimina el tag de GitHub que esta conectado con el tag eliminado dentro del proyecto en git (puede que previamente se tenga que usar pull y push para subir la referencia del tag eliminado en el proyecto de git).</dd>
            </dl>
          </dd>
          <figure>
            <img src="../Imgs/tag2.jpg" alt="ejemplo de tag mandado a GitHub" title="ejemplo de tag mandado a GitHub">
            <img src="../Imgs/tag3.jpg" alt="ejemplo de tag en GitHub" title="ejemplo de tag en GitHub">
          </figure>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
          <dt></dt>
          <dd></dd>
        </dl>
      </div>
    </section>
    <!-- Subir proyecto a GitHub -->
    <section>
      <div>
        <h2>Subir un proyecto a GitHub.</h2>
        <p>Se crea un repositorio en GitHub:</p>
        <figure>
          <img src="../Imgs/repository_paso1.jpg" alt="paso 1 para vincular un repositorio con Git y GitHub" title="paso 1 para vincular un repositorio">
          <figcaption>Se selecciona en el menu, la opción "crear repositorio".</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/repository_paso2.jpg" alt="paso 2 para vincular un repositorio con Git y GitHub" title="paso 2 para vincular un repositorio">
          <figcaption>Se le asigna nombre, descripción, publico o provado, agregar un README (introducción al proyecto" y si se desea un gitignore o/y una licencia.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/repository_paso3.jpg" alt="paso 3 para vincular un repositorio con Git y GitHub" title="paso 3 para vincular un repositorio">
          <figcaption>Se despliega la opción CLONE en donde se puede copiar la URL del repositorio para poder clonarlo.</figcaption>
        </figure>
        <p>Posicionado en la carpeta del computador en donde se tiene el proyecto que se subirá al repositorio creado se usa el comando <b>git remote add origin <u>URL copiado</u></b> para crear un "origin" con el que se descarga el repositorio y se suben cambios o aportes desde nuestro computador. Con <b>git remote -v</b> se puede comprobar que se hizo todo correctamente, aparecerá un texto que indica el origin, la URL y entre parentesis "fetch" y "push".</p>
        <img src="../Imgs/repository_paso4.jpg" alt="paso 4 para vincular un repositorio con Git y GitHub" title="paso 4 para vicular un repositorio">
        <p id="cambioRama">Si la rama principal se llama "master" se le cambia el nombre a la rama principal ya que desde 2020 se dejó de utilizar "master" para convertirse en "main" con el comando <b>git checkout <u>master</u></b> para dirigirse a la rama master, después se escribe el comando <b>git branch -m <u>main</u></b></p>
        <img src="../Imgs/repository_paso5.jpg" alt="paso 5 para vincular un repositorio con Git y GitHub" title="paso 5 para vicular un repositorio">
        <p>Se indica que las ramas principales sean main para futuros proyectos con el comando <b>git config --global init.defaultBranch <u>main</u></b></p>
        <img src="../Imgs/repository_paso6.jpg" alt="paso 6 para vincular un repositorio con Git y GitHub" title="paso 6 para vicular un repositorio">
        <p>Se envia al origen, la rama main con el comando <b>git push origin <u>main</u></b>. Si se queda pasmada la terminal de git permitiendo solo ingresar texto, entonces se presiona <i>CONTROL + c</i> para detener el proceso, después se abre otra terminal como en CMD o preferentemente una terminal de "visual studio code" y se vuelve a escribir este comando.</p>
        <img src="../Imgs/repository_paso7.jpg" alt="paso 7 para vincular un repositorio con Git y GitHub" title="paso 7 para vicular un repositorio">
        <p>Se integran los cambios remotos antes de hacer un push, para esto se importa el repositorio desde el origen, la rama main con el comando <b>git pull origin <u>main</u></b></p>
        <img src="../Imgs/repository_paso8.jpg" alt="paso 8 para vincular un repositorio con Git y GitHub" title="paso 8 para vicular un repositorio">
        <p>Se fucionan las historias no relacionadas, es decir, la rama local y la rama de GitHub con el comando <b>git pull origin main --allow-unrelated-histories</b>, esto generalmente solo se usa con el primer pull a un repositorio.</p>
        <img src="../Imgs/repository_paso9.jpg" alt="paso 9 para vincular un repositorio con Git y GitHub" title="paso 9 para vicular un repositorio">
        <p>Se sube el proyecto con todos sus commits con el comando <b>git push origin <u>main</u></b></p>
        <img src="../Imgs/repository_paso10.jpg" alt="paso 10 para vincular un repositorio con Git y GitHub" title="paso 10 para vicular un repositorio">
        <p>Se recarga la página de GitHub y se podrá visualizar los archivos y su información como sus comits o fecha de ultima modificación.</p>
        <img src="../Imgs/repository_paso11.jpg" alt="paso 11 para vincular un repositorio con Git y GitHub" title="paso 11 para vicular un repositorio">
      </div>
    </section>
    <!-- Cambiar HTTP por SSH -->
    <section>
      <div>
        <h2>Cambiar la conexión HTTP por SSH.</h2>
        <p>Después de crear la llave SSH con los comandos indicados se procede a lo siguiente:</p>
        <figure>
          <img src="../Imgs/SSH5.jpg" alt="paso 1 para conectar GitHub con SSH" title="paso 1 para conectar GitHub con SSH">
          <img src="../Imgs/SSH6.jpg" alt="paso 2 para conectar GitHub con SSH" title="paso 2 para conectar GitHub con SSH">
          <img src="../Imgs/SSH7.jpg" alt="paso 3 para conectar GitHub con SSH" title="paso 3 para conectar GitHub con SSH">
          <img src="../Imgs/SSH8.jpg" alt="paso 4 para conectar GitHub con SSH" title="paso 4 para conectar GitHub con SSH">
          <img src="../Imgs/SSH9.jpg" alt="paso 5 para conectar GitHub con SSH" title="paso 5 para conectar GitHub con SSH">
          <img src="../Imgs/SSH10.jpg" alt="paso 6 para conectar GitHub con SSH" title="paso 6 para conectar GitHub con SSH">
        </figure>
      </div>
    </section>
    <!-- Uso de ramas -->
    <section>
      <div>
        <h2>Uso de ramas.</h2>
        <dl>
          <dt>git checkout main</dt>
          <dd>Se deben crear las ramas desde la versión más resiente qu debería ser la rama main.</dd>
          <dt>git branch <span>rama's_name</span></dt>
          <dd>Se crea la rama.</dd>
          <dt>git branch</dt>
          <dd>Se verifica que se hayan creado las ramas.</dd>
          <dt>git push origin <span>rama's_name</span></dt>
          <p>Cuando se trabaja con un compañero en el proyecto, el creador del proyecto en GitHub le tiene que dar acceso al proyecto para que el compañero pueda subir sus aportaciones de código o para clonar el proyecto en caso de que sea privado.</p>
          <figure>
            <img src="../Imgs/rama1.jpg" alt="Paso 1 para dar acceso a un compañero al proyecto (settings)" title="Paso 1 para dar acceso a un compañero al proyecto (settings)">
            <img src="../Imgs/rama2.jpg" alt="Paso 2 para dar acceso a un compañero al proyecto (manage access)" title="Paso 2 para dar acceso a un compañero al proyecto (manage access)">
          </figure>
          <p>Al darle acceso a un usuario para que modifique o aporte en nuestro proyecto, nos brindarán un link para compartirlo con el usuario colaborador e invitarlo al proyecto, una vez que acepte la invitación podrá iniciar a hacer aportaciones a nuestro proyecto.</p>
          <dt>git pull origin <span>nombre_de_la_rama</span></dt>
          <dd>Importamos la rama creada a nuestro repositorio del proyecto local.</dd>
          <dt>git checkout <span>nombre_de_la_rama</span></dt>
          <dd>Nos colocamos en la rama creada para trabajar en ella.</dd>
          <dt>git commit -am "<span>mensaje_introductorio_del_commit</span>"</dt>
          <dd>Una vez modificada la rama se agregan y guardan los cambios.</dd>
          <dt>git pull origin <span>nombre_de_la_rama</span></dt>
          <dd>Se importa el repositorio por si hay cambios de otros usuarios.</dd>
          <dt>git push origin <span>nombre_de_la_rama</span></dt>
          <dd>Se suben los cambios hechos a la rama.</dd>
          <p>Generalmente es el lider del proyecto, product manager o el CTO el que se encarga de unir las ramas cuando ya el trabajo esta completado por lo que debe hacer pull con la rama que desea unir, después verifica que el código este correcto y...</p>
          <dt>git checkout <span>main</span></dt>
          <dd>Se dirige a la rama principal que es a la que se le adicionarán las aportaciones de las otras ramas.</dd>
          <dt>git merge <span>nombre_de_la_rama_secundaria</span></dt>
          <dd>Se le agregan las aportaciones de alguna rama secundaria a la rama principal.</dd>
          <dt>git pull origin <span>main</span></dt>
          <dd>Verifica que no hayan cambios externos que eviten hacer el push.</dd>
          <dt>git push origin <span>main</span></dt>
          <dd>Se sube a GitHub los cambios en el repositorio.</dd>
        </dl>
      </div>
    </section>
    <!-- Pull request -->
    <section>
      <div>
        <h2>Pull request</h2>
        <p>
<<<<<<< HEAD
          En un entorno profesional normalmente se bloquea la rama main, y para enviar código a dicha rama pasa por un "code review", ya que se realizan pruebas enviamos el código a servidores que normalmente los llamamos "staging develop" (servidores de pruebas) luego de que se realizan las pruebas pertinentes tanto de código como de la aplicación, estos pasan a el servidor de producción con un "<b>pull request</b>" (también llamado "merge request" o "push request") que une los códigos. Todo esto generalmente lo hace el líder de proyecto o el DevOps (administrador del entorno de desarrollo).
        </p>
        <figure>
          <img src="../Imgs/pullRequest1.jpg" alt="Ejemplo de creación de un 'pull request' a mano" title="Ejemplo de creación de un 'pull request' a mano">
          <figcaption>Pull request a mano.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest2.jpg" alt="Ejemplo de creación de un 'pull request' con ayuda de GitHub" title="Ejemplo de creación de un 'pull request' con ayuda de GitHub">
          <img src="../Imgs/pullRequest3.jpg" alt="Ejemplo de creación de un 'pull request' con ayuda de GitHub" title="Ejemplo de creación de un 'pull request' con ayuda de GitHub">
=======
          En un entorno profesional normalmente se bloquea la rama main, y para enviar código a dicha rama pasa por un "code review", ya que se realizan pruebas se envía el código a servidores que normalmente los llamamos "staging develop" (servidores de pruebas) luego de que se realizan las pruebas pertinentes tanto de código como de la aplicación, estos pasan a el servidor de producción con un "<b>pull request</b>" (también llamado "merge request" o "push request") que une los códigos. Todo esto generalmente lo hace el líder de proyecto o el DevOps (administrador del entorno de desarrollo).
        </p>
        <figure>
          <img src="../Imgs/pullRequest1.jpg" alt="Ejemplo de creación de un 'pull request' a mano" title="Creación de un 'pull request' a mano">
          <figcaption>Pull request a mano.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest2.jpg" alt="Ejemplo de creación de un 'pull request' con ayuda de GitHub" title="Creación de un 'pull request' con ayuda de GitHub">
          <img src="../Imgs/pullRequest3.jpg" alt="Ejemplo de creación de un 'pull request' con ayuda de GitHub" title="Creación de un 'pull request' con ayuda de GitHub">
>>>>>>> menu
          <figcaption>Pull request directo.</figcaption>
        </figure>
        <p>
          Al <i>pull request</i> se le pueden agregar detalles:<br>
          El título del <i>pull request</i> es el nombre del commit.<br/>
          Se le puede colocar una descripción o un mensaje para quien lo revise.<br/>
          En <u>reviewers</u> se le pueden agregar usuarios que lo reviser.<br/>
          En <u>assignees</u> se le asigna a un usuario.<br/>
          En <u>labels</u> se le pueden agregar etiquetas.<br/>
          En <u>project</u> se agrupan repositorios dentro de GitHub.<br/>
          En <u>milestone</u> se indica que se cumplió un objetivo que se tenía y que el <i>pull request</i> lo represeta.<br/>
          Por último se presiona el botón "Crear pull request" para ejecutarlo y que las personas solicitadas revisen el <i>pull request</i>.
        </p>
        <p>
          El <i>pull request</i> describe las acciones del código y el usuario correspondiente se encarga de revisar el código y pedir cambios o ejecutar el merge.
        </p>
        <figure>
<<<<<<< HEAD
          <img src="../Imgs/pullRequest4.jpg" alt="Ejemplo de vista del asignado de revisión o cesionario" title="Ejemplo de vista del asignado de revisión o cesionario">
          <img src="../Imgs/pullRequest5.jpg" alt="Ejemplo de vista del asignado de revisión o cesionario" title="Ejemplo de vista del asignado de revisión o cesionario">
=======
          <img src="../Imgs/pullRequest4.jpg" alt="Ejemplo de vista del asignado de revisión (reviewer) o cesionario (assignee)" title="Vista del asignado de revisión (reviewer) o cesionario (assignee)">
          <img src="../Imgs/pullRequest5.jpg" alt="Ejemplo de vista del asignado de revisión (reviewer) o cesionario (assignee)" title="Vista del asignado de revisión (reviewer) o cesionario (assignee)">
>>>>>>> menu
          <figcaption>Vista del reviewer o assignee del <i>pull request</i></figcaption>
        </figure>
        <p>
          Desde la pestaña "<i>Files changed</i>" se pueden agregar comentarios, aprobar el <i>merge</i> o pedir cambios al proyecto.
        </p>
<<<<<<< HEAD
=======
        <figure>
          <img src="../Imgs/pullRequest6.jpg" alt="Ejemplo de vista del líder de proyecto respondiendo la solicitud del reviewer" title="Vista del líder de proyecto: respondiendo la solicitud del reviewer">
          <figcaption>Vista del líder del proyecto ya listo para pedír de nuevo una revisión para autorizar un merge.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest7.jpg" alt="Ejemplo de vista del reviewer revisando los cambios" title="Vista del reviewer: revisando los cambios">
          <figcaption>Vista del reviewer revisando los cambios. Se visualiza la última aportación o commit.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest8.jpg" alt="Ejemplo de vista del reviewer aprobando los cambios" title="Vista del reviewer: aprobando los cambios">
          <figcaption>Vista del reviewer aprobando los cambios.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest9.jpg" alt="Ejemplo de vista del líder de proyectos comenzando el merge de las ramas completas" title="Vista del líder de proyectos: comenzando el merge de las ramas completas">
          <img src="../Imgs/pullRequest10.jpg" alt="Ejemplo de vista del líder de proyectos realizando el merge" title="Vista del líder de proyectos: realizando el merge">
          <figcaption>Vista del líder de proyectos realizando el merge de las ramas completas.</figcaption>
        </figure>
        <figure>
          <img src="../Imgs/pullRequest11.jpg" alt="Ejemplo de vista del líder de proyectos eliminando Branch (rama)" title="Vista del líder de proyectos: eliminando Branch (rama)">
          <figcaption>Vista del líder del proyecto. Una vez que el merge se realizó se puede eliminar la rama si es que ya no se utilizará, aunque esta opción no eliminará la rama en el entorno de trabajo en Git.</figcaption>
        </figure>
      </div>
    </section>
    <!-- Colaboración y Fork -->
    <section>
      <div>
        <h2>Colaboración.</h2>
        <p>Un colaborador es un usuario que sugiere aportaciones al proyecto sin ser parte del equipo de trabajo del proyecto.</p>
        <p>
          Para ser un colaborador de algún proyecto se necesita:
          <dl>
            <dt>Activar Watch</dt>
            <dd>Con esta función podremos recibir notificaciones en el momento en que haya conversaciones del proyecto.</dd>
            <dt>Star</dt>
            <dd>Indica que un proyecto nos gusta y nos permite recibir notificaciones si hay cambios en el proyecto.</dd>
            <dt>Fork</dt>
            <dd>Toma una copia del estado actual del proyecto y lo clona como un proyecto propio si es que el proyecto es público.</dd>
          </dl>
        </p>
        <figure>
          <img src="../Imgs/colab1.jpg" alt="Ejemplo de las funciones en GitHub para iniciar a colaborar" title="Funciones Watch, Star y Fork">
        </figure>
        <p>Se clona el proyecto al disco duro con la opción <i>code</i>, y depende si se implementaron la llave SSH o solo la HTTPS en tu computadora se selecciona la opción respectiva.</p>
        <figure>
          <img src="../Imgs/colab2.jpg" alt="Ejemplo de las funciones en GitHub para iniciar a colaborar" title="Funciones Watch, Star y Fork">
        </figure>
        <p>En la terminal de la computadora personal se posiciona en el directorio en el que se desea almacenar el proyecto que se clonó en GitHub con el comando <b>cd</b> y seguido a eso se usa el comando "<b>git clone <span> URL_copiada</span></b>" para copiar el proyecto al disco duro en el directorio especificado.</p>
        <p>Si se hacen cambios y contribuciones al proyecto clonado se puede crear un <b>pull request</b> y nos conecta directamente con el proyecto original. Se puede pedir que se agreguen las contribuciones si es que no hay conflictos con el repositorio original, después se puede esperar, agregar comentarios al <i>pull request</i> o cerrar (eliminar) el <i>pull request</i>.</p>
        <p>Si el dueño o líder del proyecto acepta el <i>pull request</i> le hará un merge.</p>
        <h3>Fork</h3>
        <p>Para mantener actualizado el proyecto se crea una rama especial</p>
        <dl>
          <dt>git remote add <span>upstream URL_(HTTPS_o_SSH)</span></dt>
          <dd>Con este comando se crea una nueva rama, generalmente se usa el nombre "upstream" en la rama que se utiliza como un remoto para importar datos de un proyecto que es ajeno y así poder fusionarlo a la rama principal de nuestro proyecto importado.</dd>
          <dd>El URL que se utiliza es el del proyecto ajeno que queremos clonar contantemente para mantener actualizados sus cambios.</dd>
          <dt>git pull <span>upstream</span> main</dt>
          <dd>Importa a "upstream" el contenido que hay en la rama "main".</dd>
          <dt>git commit -am "<span>mensaje</span>"</dt>
          <dd>Hace un commit a upstream.</dd>
          <dt>git push origin main</dt>
          <dd>Hace un push con los cambios.</dd>
        </dl>
        <p>La rama "upstream" es un apuntador que apunta hacia el repositorio de GitHub original, cada que el proyecto original hace cambios, éste se actualizará con el pull y luego enviará los cambios a nuestro main local.</p>
      </div>
    </section>
    <!-- GitIgnore -->
    <section>
      <div>
        <h2>GitIgnore</h2>
        <p>Se crea un archivo nuevo y se guarda en la <b>raíz</b> de la rama del proyecto con el nombre de <b>.gitignore</b></p>
        <img src="../Imgs/ignore1.jpg" alt="Ejemplo del archivo guardado como .gitignore" title="Ejemplo del archivo guardado.">
        <p>En este documento se colocarán los tipos de archivo que se gnorarán al hacer push. Como es mala practica agregar archivos binarios a un repositorio, se agregarán las instrucciones correspondientes para que se ignoren los archivos que sean imagenes o videos.</p>
        <img src="../Imgs/ignore2.jpg" alt="Ejemplo de instrucciones en el archivo .gitignore" title="Ejemplo de instrucciones.">
        <p>La sintaxis de este archivo incluye:</p>
        <dl>
          <dt>#Texto</dt>
          <dd>Con los "#" se colocan comentarios.</dd>
          <dt>/content/tmp/*</dt>
          <dd>Ignorará todo el contenido de la carpeta "tmp" que esta dentro de la carpeta "content" de la raíz del proyecto.</dd>
          <dt>/apps/imagenes/**/*</dt>
          <dd>Ignorará tod el contenido de todas las carpetas que estén en el directorio especificado.</dd>
          <dt>!/content/**/README.md</dt>
          <dd>El simbolo "!" es una excepción. Si se elimina algún archivo de cualquier carpeta que esté dentro de la carpeta content, no se eliminarán los "README.md".</dd>
        </dl>
      </div>
    </section>
    <!-- README.md -->
    <section>
      <div>
        <h2>README.md</h2>
        <p>Es una excelente práctica en los proyectos, <b>md</b> significa Markdown, que es una especie de código que te permite cambiar la manera en que se ve un archivo de texto.</p>
        <p>Lo interesante de Markdown es que funciona en muchas páginas, por ejemplo la edición en Wikipedia; es un lenguaje intermedio que no es HTML, no es texto plano, es una manera de crear excelentes texto formateados, pero puede interpretar código html y texto plano o texto de marcado como el uso de hash (#text) para marcar títulos o subtítulos (##text, ###text) dentro del contenido.</p>
        <p>Se puede aprender mucho de los proyectos <i>opensource</i>, ejemplo: <a target="_blank" href="https://github.com/vuejs/vue" title="Proyecto ejemplo">vuejs/vue</a></p>
        <figure>
          <img src="../Imgs/readmemd1.jpg" alt="Ejemplo del archivo README.md dentro del proyecto de vue" title="README.md dentro de vue">
          <img src="../Imgs/readmemd2.jpg" alt="Botón de edición del archivo README.md" title="edición de README.md">
        </figure>
        <p>Se puede editar el archivo README.md abriendolo directamente o mediante un editor online como <a target="_blank" href="https://pandao.github.io/editor.md/en.html" title="Editor online">MEditor.md</a></p>
      </div>
    </section>
    <!-- GitHub-Pages -->
    <section>
      <div>
        <h2>GitHub-Pages</h2>
        <p>GitHub tiene un servicio de hosting gratis llamado <a target="_blank" href="https://pages.github.com/">GitHub Pages</a>, tu puedes tener un repositorio donde el contenido del repositorio se vaya a GitHub y se vea online.</p>
        <h3>Paso 1:</h3>
        <p>Crear un repositorio público con el nombre del usuario agregandole ".github.io" (si ya tienes un repositorio con tu nombre de usuario solo cambiale el nombre dirigiendote a la pestaña Settings).</p>
        <figure>
          <img src="../Imgs/ghPages1.jpg" alt="Ejemplo de creación del repositorio" title="Creción de repositorio">
        </figure>
        <h3>Paso 2:</h3>
        <p>Se copia el URL del repositorio dependiendo si se tiene configurada la llave SSH o no y desde la terminal git se clona el repositorio (se debe posicionarse en la carpeta donde se desea clonarlo) con el comando <b>git clone <span>URL</span></b>.</p>
        <figure>
          <img src="../Imgs/colab2.jpg" alt="Ejemplo de copiado de URL (HTML o SSH) del repositorio" title="URL de repositorio">
        </figure>
        <h3>Paso 3:</h3>
        <p>Se crea un achivo "index.html" dentro de la carpeta del proyecto con el nombre de usuario que se crea al clonar el repositorio y desde la terminal git se hace un <b>add</b> y <b>commit</b> para agregarlo a GitHub.</p>
        <h3>Paso 4:</h3>
        <p>Se configura el repositorio para que sea el que carga GitHub Pages entrando a la pestaña <b>Settings</b> y se selecciona la sección <b>Pages</b> en la que se verifica que se este usando la rama deseada que se visualizará en la página, generalmente es la rama <b>main</b>.</p>
        <figure>
          <img src="../Imgs/rama1.jpg" alt="Ejemplo de la pestaña Settings" title="Pestaña Settings">
          <img src="../Imgs/ghPages2.jpg" alt="Ejemplo de la sección Pages opción Source" title="Sección Pages">
        </figure>
        <h4>Tip:</h4>
        <p>Se tienen que cargar los archivos en el repositorio que se quieran usar en la página como los archivos binarios.</p>
        <h3>Paso Extra:</h3>
        <p>Si se desea hacer los mismos pasos con un repositorio con otro nombre, se tiene que agreagar el origen de la página en el link, ejemplo:</p>
        <figure>
          <img src="../Imgs/ghPages3.jpg" alt="Ejemplo del cambio de rama en un repositorio con un nombre distinto al nombre del usuario" title="Cambio de rama en la sección Pages">
          <img src="../Imgs/ghPages4.jpg" alt="Ejemplo de error 404 con el link que genera GitHub" title="Error con el link generado">
        </figure>
        <p>Al link que nos crea GitHub Pages: <u>https://patokuack.github.io/DisenoWeb/</u> se le adiciona la carpeta o archivo en donde se encuentra el documento a visualizar HTML: <u>HTML/Paginas/indexhtml.html</u></p>
      </div>
    </section>
    <section>
      <div>
        <h3>Referencias:</h3>
        <p><a target="_blank" href="https://platzi.com/clases/1557-git-github/23295-git-reset-vs-git-rm/">rm y reset</a></p>
        <p><a target="_blank" href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a></p>
        <p><a target="_blank" href="https://danielkummer.github.io/git-flow-cheatsheet/">Git-flow cheatsheet</a></p>
      </div>
    </section>
  </main>
  <script src="../Programacion/jsGit1.js"></script>
</body>
</html>